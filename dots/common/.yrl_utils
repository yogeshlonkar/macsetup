# vim: set ft=bash:
# utility functions

function fstrigger()
{
  local re delay to_watch to_execute red green lockfile
  lockfile="${HOME}/.fstrigger_$((1 + RANDOM % 10000))"

  re='^[0-9]+$'
  if [[ ${1} =~ ${re} ]] ; then
    delay=${1}
    set -- "${@:2}"
  else
    delay=2
  fi
  if [[ -f ${1} || -d ${1} ]]; then
     to_watch=${1}
     to_execute=${@:2}
  else
     to_watch=`pwd`
     to_execute=${@}
  fi

  function yrl_locked_command()
  {
	if (set -o noclobber; echo "$$" > "${lockfile}") 2> /dev/null; then
	  trap 'rm -f "$lockfile"; exit $?' INT TERM EXIT
      echo -e "\033[1;36mtriggered\033[0m"
      color=${red}
      eval ${to_execute[@]} && color=${green} || true
      echo -e "\n${color}trigger-finished\033[0m\n"
      sleep ${delay}
      # _lock u;
	  rm -f "${lockfile}"
	  trap - INT TERM EXIT
    fi
  }
  red='\033[1;31m'
  green='\033[1;32m'
  echo "Watching ${to_watch} with delay ${delay} lockfile ${lockfile}"
  fswatch -e *.swp -xnr ${to_watch} | while read -d 1; do
    yrl_locked_command &
  done
}

function sanitize()
{
  for fname in "${@}"
  do
    gcat -v ${fname} | sed 's/M-BM-//g' > ${fname}.bkp
    mv ${fname}.bkp ${fname}
  done
}

function mfa()
{
  if [[ -z "${OP_SESSION_my}" ]]; then
   eval $(op signin my)
  fi
  echo "MFA copied, valid for $(expr 30 - $(date +%s) % 30)s"
  op get totp rkdtjsgg4raf3p4b2zlxvpskay | pbcopy
}

function gpg_pass()
{
  op get item "GPG Passphrase" | jq -r '.details.password' | pbcopy
}

function dazn_aws_set_env()
{
  mfa
  if [[ -z ${1} ]]; then
    acc=dazn-payments-dev
  else
    acc=${1}
  fi
  echo "Using ${acc}"
  dazn aws exec -p ${acc} -- echo ""
  eval "$(dazn aws exec -p ${acc} -- printenv | grep AWS_ | sed 's/^/export /g')"
}

function git_branch_cleanup()
{
  if [[ "${1}" == "-f" ]]; then
    git branch -va | grep gone | awk '{print $1}' | xargs git branch -D
  else
    git branch -va | grep gone
    echo 'For cleanup run git_branch_cleanup -f'
  fi
}

function touchy()
{
  local files=$(echo ${@} | sed -e 's/^[+-=][rstwxXugo]* //g')
  local chmod_flags=$(echo ${@} | sed -e 's/^\([+-=][rstwxXugo]*\) .*/\1/g')
  # echo "Files $files"
  # echo "chmod_flags $chmod_flags"
  touch "${files}"
  if [[ -n "${chmod_flags}" ]]; then
    chmod "${chmod_flags}" "${files}"
  fi
}

function _print_script_with_sources() {
  local script_to_read=$(eval "realpath ${1}" 2>/dev/null)
  local padding=${2}
  if ! [[ -f "${script_to_read}" ]]; then
    1>&2 echo -e "Usage:\n_print_script_with_sources path/to/script"
    return 1
  fi

  IFS=''
  cat "${script_to_read}" | while read linex; do
    if [[ "${linex}" = *"source "* ]]; then
      local sourced_file=$(echo -e "${linex}" | sed -e 's/[[:space:]]*$//' -e 's/^[[:space:]]*//' -e 's/^source[[:space:]]*\([^ *]\)/\1/g')
      sourced_file=$(eval "realpath ${sourced_file}" 2>/dev/null)
      if [[ -f "${sourced_file}" ]]; then
        echo -e "${padding}# ${linex}"
        _print_script_with_sources "${sourced_file}" "${padding}   "
        continue
      fi
    fi
    echo -e "${padding}${linex}"
  done
}

function _bash_profile() {
  _print_script_with_sources ~/.bash_profile
}
